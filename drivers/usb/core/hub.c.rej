--- drivers/usb/core/hub.c	2013-01-04 04:01:35.000000000 -0800
+++ drivers/usb/core/hub.c	2013-03-19 04:00:55.000000000 -0700
@@ -1838,29 +1437,15 @@
 	for (delay_time = 0;
 			delay_time < HUB_RESET_TIMEOUT;
 			delay_time += delay) {
-		/* wait to give the device a chance to reset */
+		
 		msleep(delay);
 
-		/* read and decode port status */
+		
 		ret = hub_port_status(hub, port1, &portstatus, &portchange);
 		if (ret < 0)
 			return ret;
 
-		/*
-		 * Some buggy devices require a warm reset to be issued even
-		 * when the port appears not to be connected.
-		 */
 		if (!warm) {
-			/*
-			 * Some buggy devices can cause an NEC host controller
-			 * to transition to the "Error" state after a hot port
-			 * reset.  This will show up as the port state in
-			 * "Inactive", and the port may also report a
-			 * disconnect.  Forcing a warm port reset seems to make
-			 * the device work.
-			 *
-			 * See https://bugzilla.kernel.org/show_bug.cgi?id=41752
-			 */
 			if (hub_port_warm_reset_required(hub, portstatus)) {
 				int ret;
 
@@ -1883,17 +1468,14 @@
 							USB_PORT_FEAT_C_CONNECTION);
 				return ret;
 			}
-			/* Device went away? */
+			
 			if (!(portstatus & USB_PORT_STAT_CONNECTION))
 				return -ENOTCONN;
 
-			/* bomb out completely if the connection bounced */
+			
 			if ((portchange & USB_PORT_STAT_C_CONNECTION))
 				return -ENOTCONN;
 
-			/* if we`ve finished resetting, then break out of
-			 * the loop
-			 */
 			if (!(portstatus & USB_PORT_STAT_RESET) &&
 			    (portstatus & USB_PORT_STAT_ENABLE)) {
 				if (hub_is_wusb(hub))
@@ -1913,7 +1495,7 @@
 				return 0;
 		}
 
-		/* switch to the long delay after two short delay failures */
+		
 		if (delay_time >= 2 * HUB_SHORT_RESET_TIME)
 			delay = HUB_LONG_RESET_TIME;
 
@@ -1932,7 +1514,7 @@
 	case 0:
 		if (!warm) {
 			struct usb_hcd *hcd;
-			/* TRSTRCY = 10 ms; plus some extra */
+			
 			msleep(10 + 40);
 			update_devnum(udev, 0);
 			hcd = bus_to_hcd(udev->bus);
@@ -1945,12 +1527,12 @@
 				}
 			}
 		}
-		/* FALL THROUGH */
+		
 	case -ENOTCONN:
 	case -ENODEV:
 		clear_port_feature(hub->hdev,
 				port1, USB_PORT_FEAT_C_RESET);
-		/* FIXME need disconnect() for NOTATTACHED device */
+		
 		if (warm) {
 			clear_port_feature(hub->hdev, port1,
 					USB_PORT_FEAT_C_BH_PORT_RESET);
@@ -1965,16 +1547,12 @@
 	}
 }
 
-/* Handle port reset and port warm(BH) reset (for USB3 protocol ports) */
 static int hub_port_reset(struct usb_hub *hub, int port1,
 			struct usb_device *udev, unsigned int delay, bool warm)
 {
 	int i, status;
 
 	if (!warm) {
-		/* Block EHCI CF initialization during the port reset.
-		 * Some companion controllers don't like it when they mix.
-		 */
 		down_read(&ehci_cf_port_reset_rwsem);
 	} else {
 		if (!hub_is_superspeed(hub->hdev)) {
@@ -2002,7 +1580,7 @@
 						status);
 		}
 
-		/* return on disconnect or reset */
+		
 		if (status == 0 || status == -ENOTCONN || status == -ENODEV) {
 			hub_port_finish_reset(hub, port1, udev, &status, warm);
 			goto done;
@@ -2160,7 +1673,7 @@
 	if (status) {
 		dev_dbg(hub->intfdev, "can't suspend port %d, status %d\n",
 				port1, status);
-		/* paranoia:  "should not happen" */
+		
 		if (udev->do_remote_wakeup)
 			(void) usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
 				USB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,
@@ -2251,51 +1739,17 @@
 					USB_DEVICE_REMOTE_WAKEUP, 0,
 					NULL, 0,
 					USB_CTRL_SET_TIMEOUT);
-			/*if (status)*/ /* ++SSD_RIL */
+			 
 				dev_info(&udev->dev,
 					"disable remote wakeup, status %d\n",
 					status);
-				/* --SSD_RIL */
+				
 		}
 		status = 0;
 	}
 	return status;
 }
 
-/*
- * usb_port_resume - re-activate a suspended usb device's upstream port
- * @udev: device to re-activate, not a root hub
- * Context: must be able to sleep; device not locked; pm locks held
- *
- * This will re-activate the suspended device, increasing power usage
- * while letting drivers communicate again with its endpoints.
- * USB resume explicitly guarantees that the power session between
- * the host and the device is the same as it was when the device
- * suspended.
- *
- * If @udev->reset_resume is set then this routine won't check that the
- * port is still enabled.  Furthermore, finish_port_resume() above will
- * reset @udev.  The end result is that a broken power session can be
- * recovered and @udev will appear to persist across a loss of VBUS power.
- *
- * For example, if a host controller doesn't maintain VBUS suspend current
- * during a system sleep or is reset when the system wakes up, all the USB
- * power sessions below it will be broken.  This is especially troublesome
- * for mass-storage devices containing mounted filesystems, since the
- * device will appear to have disconnected and all the memory mappings
- * to it will be lost.  Using the USB_PERSIST facility, the device can be
- * made to appear as if it had not disconnected.
- *
- * This facility can be dangerous.  Although usb_reset_and_verify_device() makes
- * every effort to insure that the same device is present after the
- * reset as before, it cannot provide a 100% guarantee.  Furthermore it's
- * quite possible for a device to remain unaltered but its media to be
- * changed.  If the user replaces a flash memory card while the system is
- * asleep, he will have only himself to blame when the filesystem on the
- * new card is corrupted and the system crashes.
- *
- * Returns 0 on success, else negative errno.
- */
 int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 {
 	struct usb_hub	*hub = hdev_to_hub(udev->parent);
