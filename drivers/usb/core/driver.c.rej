--- drivers/usb/core/driver.c	2013-01-04 04:01:35.000000000 -0800
+++ drivers/usb/core/driver.c	2013-03-19 04:00:55.000000000 -0700
@@ -1069,70 +763,43 @@
 {
 	int	w;
 
-	/* Remote wakeup is needed only when we actually go to sleep.
-	 * For things like FREEZE and QUIESCE, if the device is already
-	 * autosuspended then its current wakeup setting is okay.
-	 */
 	if (msg.event == PM_EVENT_FREEZE || msg.event == PM_EVENT_QUIESCE) {
 		if (udev->state != USB_STATE_SUSPENDED)
 			udev->do_remote_wakeup = 0;
 		return;
 	}
 
-	/* Enable remote wakeup if it is allowed, even if no interface drivers
-	 * actually want it.
-	 */
 	w = device_may_wakeup(&udev->dev);
 
-	/* If the device is autosuspended with the wrong wakeup setting,
-	 * autoresume now so the setting can be changed.
-	 */
 	if (udev->state == USB_STATE_SUSPENDED && w != udev->do_remote_wakeup)
 		pm_runtime_resume(&udev->dev);
 	udev->do_remote_wakeup = w;
 }
 
-/* The device lock is held by the PM core */
 int usb_suspend(struct device *dev, pm_message_t msg)
 {
 	struct usb_device	*udev = to_usb_device(dev);
 
 	unbind_no_pm_drivers_interfaces(udev);
 
-	/* From now on we are sure all drivers support suspend/resume
-	 * but not necessarily reset_resume()
-	 * so we may still need to unbind and rebind upon resume
-	 */
 	choose_wakeup(udev, msg);
 	return usb_suspend_both(udev, msg);
 }
 
-/* The device lock is held by the PM core */
 int usb_resume_complete(struct device *dev)
 {
 	struct usb_device *udev = to_usb_device(dev);
 
-	/* For PM complete calls, all we do is rebind interfaces
-	 * whose needs_binding flag is set
-	 */
 	if (udev->state != USB_STATE_NOTATTACHED)
 		do_rebind_interfaces(udev);
 	return 0;
 }
 
-/* The device lock is held by the PM core */
 int usb_resume(struct device *dev, pm_message_t msg)
 {
 	struct usb_device	*udev = to_usb_device(dev);
 	int			status;
 
-	/* For all calls, take the device back to full power and
-	 * tell the PM core in case it was autosuspended previously.
-	 * Unbind the interfaces that will need rebinding later,
-	 * because they fail to support reset_resume.
-	 * (This can't be done in usb_resume_interface()
-	 * above because it doesn't own the right set of locks.)
-	 */
 	pm_runtime_get_sync(dev->parent);
 	status = usb_resume_both(udev, msg);
 	if (status == 0) {
