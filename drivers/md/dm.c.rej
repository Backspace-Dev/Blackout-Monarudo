--- drivers/md/dm.c	2013-01-04 04:01:37.000000000 -0800
+++ drivers/md/dm.c	2013-03-19 04:01:01.000000000 -0700
@@ -597,62 +490,30 @@
 	bio_put(clone);
 
 	if (tio->error)
-		/*
-		 * An error has already been detected on the request.
-		 * Once error occurred, just let clone->end_io() handle
-		 * the remainder.
-		 */
 		return;
 	else if (error) {
-		/*
-		 * Don't notice the error to the upper layer yet.
-		 * The error handling decision is made by the target driver,
-		 * when the request is completed.
-		 */
 		tio->error = error;
 		return;
 	}
 
-	/*
-	 * I/O for the bio successfully completed.
-	 * Notice the data completion to the upper layer.
-	 */
-
-	/*
-	 * bios are processed from the head of the list.
-	 * So the completing bio should always be rq->bio.
-	 * If it's not, something wrong is happening.
-	 */
+
 	if (tio->orig->bio != bio)
 		DMERR("bio completion is going in the middle of the request");
 
-	/*
-	 * Update the original request.
-	 * Do not use blk_end_request() here, because it may complete
-	 * the original request before the clone, and break the ordering.
-	 */
 	blk_update_request(tio->orig, 0, nr_bytes);
 }
 
-/*
- * Don't touch any member of the md after calling this function because
- * the md may be freed in dm_put() at the end of this function.
- * Or do dm_get() before calling this function and dm_put() later.
- */
 static void rq_completed(struct mapped_device *md, int rw, int run_queue)
 {
 	atomic_dec(&md->pending[rw]);
 
-	/* nudge anyone waiting on suspend queue */
+	
 	if (!md_in_flight(md))
 		wake_up(&md->wait);
 
 	if (run_queue)
 		blk_run_queue(md->queue);
 
-	/*
-	 * dm_put() must be at the end of this function. See the comment above
-	 */
 	dm_put(md);
 }
 
@@ -1329,40 +1071,28 @@
 	return BLKPREP_OK;
 }
 
-/*
- * Returns:
- * 0  : the request has been processed (not requeued)
- * !0 : the request has been requeued
- */
 static int map_request(struct dm_target *ti, struct request *clone,
 		       struct mapped_device *md)
 {
 	int r, requeued = 0;
 	struct dm_rq_target_io *tio = clone->end_io_data;
 
-	/*
-	 * Hold the md reference here for the in-flight I/O.
-	 * We can't rely on the reference count by device opener,
-	 * because the device may be closed during the request completion
-	 * when all bios are completed.
-	 * See the comment in rq_completed() too.
-	 */
 	dm_get(md);
 
 	tio->ti = ti;
 	r = ti->type->map_rq(ti, clone, &tio->info);
 	switch (r) {
 	case DM_MAPIO_SUBMITTED:
-		/* The target has taken the I/O to submit by itself later */
+		
 		break;
 	case DM_MAPIO_REMAPPED:
-		/* The target has remapped the I/O so dispatch it */
+		
 		trace_block_rq_remap(clone->q, clone, disk_devt(dm_disk(md)),
 				     blk_rq_pos(tio->orig));
 		dm_dispatch_request(clone);
 		break;
 	case DM_MAPIO_REQUEUE:
-		/* The target wants to requeue the I/O */
+		
 		dm_requeue_unmapped_request(clone);
 		requeued = 1;
 		break;
